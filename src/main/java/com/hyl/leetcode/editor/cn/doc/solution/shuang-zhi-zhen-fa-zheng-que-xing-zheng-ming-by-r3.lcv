# 双指针法正确性证明

以`i,j`表示前后指针，`H[i]`表示位置i处的高度，`n`是输入的数据长度。$S(i,j) = min(H[i],H[j]) * (j - i)$是`(i,j)`对的面积。

## 已知最大性

根据双指针法的求解过程，可以很容易得到一个性质：

> `H[i]`与`H[j]`中至少有一个是在$(0,i]$和$[j,n-1)$中，H最大的。

反证一下，很容易证得上述性质。

将$(0, i)$与$(j, n -1)$称为已知区域，$[i,j]$中间所有序偶对称未知区域。

假设已知区域有`H[k]`为最大值，比`H[i]`和`h[j]`都大。那么很明显算法执行到`k`之后，将不可能获得移动机会，算法不可能移动到`[i, j]`状态。因此假设不成立。

## 安全性

深入思考，移动较小指针到底意味着什么？
每移动一次较小指针，意味着计算了一对$S(i, j)$的值，而消去了一排$S(i, k), i < k <= j$
我们定义移动指针的安全性：
如果一次移动指针，消去的所有$(i, j)$对，要么是被计算过，要么是可证明的小于某个已计算过的$S(i, j)$，那么我们可以说这一次指针移动是`安全`的。

以初始状态为例，$(i, j) = (0, n-1)$，那么该状态将计算$S(0, n-1)$。

如果`H[0] < H[n-1]`，那么将消去$(0, 1), (0,2) , ... , (0,n)$等$n-1$个状态。

而如果`H[0] > H[n-1]`，那么将消去$(0, n-1), (1, n-1), ... ,(n - 2, n - 1)$等$n-1$个状态。

定义消去集为$X$ ,待解集$R$，$R_i  = R_{i-1} - X$

## 证明

(1) 算法的初始状态是安全的。

算法的初始状态，待解集合$R = \{(i, j), 0 <= i < j <= n-1 \}$，而正确状态一定位于`R`中。

初始状态是安全的。

(2) 若第$k$个状态是安全的，那么完成移动小指针操作得到的第$k+1$个状态也是安全的。

从状态$k$到状态$k+1$，算法完成了一次消去操作，

1. `H[i] < H[j]` ，完成的是消去$X = \{(i, i+1), (i, i +2), ... , (i, j)\}$。

$\forall (i, j')\in X , S(i, j') = \begin{cases}H[i] * (j' - i)  & \text{H[i] < H[j']}\\H[j'] *(j' - i) & \text{H[i] > H[j']}\end{cases}$

如果`H[i] < H[j']`，那么$S(i, j') = H[i] * (j' - i) < H[i] *(j - i) = S(i, j )$，$X$中的状态都小于$S(i, j )$。

如果`H[i] >= H[j']` ，那么$S(i, j') = H[j'] * (j' - i) <= H[i] * (j' - i) < H[i] * (j - i) = S(i, j)$，$X$中的状态都小于$S(i, j )$。

因此，`H[i] < H[j]`时，从R中消去X集合是安全的。

2. `H[i] >= H[j]` , 其实是与情形1对称的，边界*等于*归到任意一边不影响。

$X = {(i, j), (i+1, j), ... , (j-1, j)}$。考虑$(i', j)$：
如果`H[i'] < H[j]` , 那么$S(i', j) = H[i'] * (j - i') < H[j] * (j - i') < H[j] * (j - i) =S(i, j)$

如果`H[i'] >= H[j]`， 那么$S(i', j) = H[j] * (j - i') < H[j] * (j - i) = S(i, j)$

因此，`H[i] >= H[j]`时，从$R$中消去$X$是安全的

由1.2.可知，从$R$中消去$X$是安全的

由(1)(2)可推知，算法的任一状态都是安全的。

## 重新证明

其实对于状态0，算法计算了一个状态$(0, n-1)$， 跳过了$(n - 1 - 1)$个状态，

对于状态1，算法计算了一个状态$(1, n-1)或(0,n-2)$， 跳过了$(n - 2 - 1)$个状态，

……

对于状态k,算法计算了一个状态$(i,j)$，跳过了$(n - (k + 1)- 1)$个状态，

……

当程序终止时，无论左右指针具体是如何移动的，只要每一步都移动小指针，那么程序终止时，一定移动了$(n - 2)$步。

那么一共计算了$St = (n - 1)$个状态，跳过了$Sp = (n - 1 - 1) + (n - 2  - 1) + …… + (n - (n - 1) - 1) = 1 + 2 + …… + (n-2)$个状态

那么总共是$Sum = Sp + St = 1 + 2 + …… + (n - 2) + (n - 1) = n(n-1)/2$

而认真一想，所有这些状态，都没有重复的。(自行思考)

那么，算法理论上应该经历多少状态？

对于暴力法，实际上是从$n$个数字里边挑两个构成一对的组合问题。因此一共有$C_{n}^{2} = n(n-1)/2$对

与双指针法实际考虑到的状态数是一样的，而双指针法并没有重复的考虑，因此，`双指针法是正确的`。

## 图例

![maxArea.png](https://pic.leetcode-cn.com/75617bec007da50bbd4ed69c4179a88319364ee4401e5ad35f4c68430e8cfd8c-maxArea.png)

