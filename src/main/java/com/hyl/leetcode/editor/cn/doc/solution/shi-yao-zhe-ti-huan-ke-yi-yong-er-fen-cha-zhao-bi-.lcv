#### 先验知识

先说题目 [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)。这道题知道怎么做并且知道原理的，可以直接跳过这一段~

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

这是一道非常经典的题目，用 **异或** 可以轻松解决 —— **所有的数字异或起来，就是答案**。

**为什么呢？**

![image.png](https://pic.leetcode-cn.com/88314642fa2807e5cf255dd2c653ca4e358862084c01ee53cff660af92cefe82-image.png)
(小问号你是否有很多朋友)

我们先来看下异或的性质（数学里异或的符号是 $\oplus$）：

* 交换律：$p \oplus q = q \oplus p$
* 结合律：$p \oplus (q \oplus r) = (p \oplus q) \oplus r$
* 恒等率：$p \oplus 0 = p$
* 归零率：$p \oplus p = 0$

那么，如果有若干个数字进行异或操作：
$a_{1} \oplus a_{2} \oplus ... \oplus a_{n}$
我们可以根据 **交换律**、 **结合律** 将相同的数字优先两两进行异或运算。此时根据 **归零率** ，每两个相同的数字都变成了 $0$，再根据 **恒等率** ，把式子里所有的 $0$ 去了，此时就只剩下只出现一次的那个数了！

---

#### 面试题56 - I. 数组中数字出现的次数

我们回到今天的这道题上来。如果我们对所有的数字进行异或，假设只出现一次的数字分别是 $p$ 和 $q$，那么最终的结果 $p \oplus q$，此时我们不知道 $p$ 和 $q$ 分别是什么。但是如果我们能把 $p$ 和 $q$ 从 数组里面区分开来呢？假设我们知道了某个数 $r$，$r$ 是介于 $p$ 和 $q$ 之间，那么我们可以把整个数组分成两部分 —— $a_{i}<=r$ 或 $a_{i}>r$。并且，一个数组里有 $p$，另一个数组里有 $q$。那么对这两部分的数字分别求异或和，结果就变成了 $p$ 和 $q$ 。**完美！这样就把问题转换成了我们已经解决的问题上了**！

~~在某次消防演习中，消防员问一程序员如果公司着火要怎么办，程序员回答使用灭火器灭火。消防员再问，如果没有着火怎么办？程序员回答把公司点着，这样就把问题归结到一个已经解决的问题上了！手动划掉~~

我举个栗子来说一下上面的想法：
我们看下数组 `[1,2,10,4,1,4,3,3]`，我们知道 $p$ 和 $q$ 是 2 和 10。
中间的数字我们假设是 3，根据 $a_{i}<=3$ 和 $a_{i}>3$ 划分成了`[1,2,1,3,3]` 和 `[10,4,4]`。这两个数组分别异或就是 2 和 10。

但是还没有解决，怎么找到 $p$ 和 $q$ 中间的数字 $r$ 呢？

**二分！！！**

为什么是**二分**呢？一个暴力的方法就是从数组最小的元素到最大的元素枚举所有可能的 $r$，然后根据 $a_{i}<=r$ 和 $a_{i}>r$ 化成两个数组，再看两个数组的异或和是不是都不为 0，如果是，那我们就找到了 $r$。**但是注意到，在枚举 $r$ 的时候，两个数组的异或和是否为0这个性质是单调的！**

下图是从数组最小的元素到最大的元素枚举 $r$  的过程。

为了更能体现出来单调的性质，我把 $r=0$ 和 $r=11$ 也加进来了。
![image.png](https://pic.leetcode-cn.com/2b3b1395592d907fdefb00659892ea91dbbcc95cdff9272c86887266d270f7c1-image.png)

简单来说，
* 如果当前左边的数组异或和为 $0$, 右边不为 $0$，说明当前枚举的 $r$ 小了；
* 如果当前左边的数组异或和不为 $0$, 右边也不为 $0$，说明当前枚举的 $r$ 是符合要求的，左右数组异或的结果就是答案；
* 如果当前左边的数组异或和不为 $0$, 右边为 $0$，说明当前枚举的 $r$ 大了；

这就是单调的样子。所以可以二分。

**记住，只要符合单调，就可以二分！！！**

但是，你以为这完了吗？异或和为 $0$ 其实并不代表 要找的元素不在这里面，**因为有可能 $0$ 只出现了 $1$ 次！** 所以这种思路需要特判一下某个数为 $0$ 的情况。

* []

```Java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, zeroCount = 0;
        for (int num: nums) {
            if (num == 0) {
                zeroCount += 1;
            }
            min = Math.min(min, num);
            max = Math.max(max, num);
            sum ^= num;
        }
        // 需要特判一下某个数是0的情况。
        if (zeroCount == 1) {
            return new int[]{sum, 0};
        }
        int lo = min, hi = max;
        while (lo <= hi) {
            // 根据 lo 的正负性来判断二分位置怎么写，防止越界。
            int mid = (lo < 0 && hi > 0)? (lo + hi) >> 1: lo + (hi - lo) / 2;
            int loSum = 0, hiSum = 0;
            for (int num: nums) {
                if (num <= mid) {
                    loSum ^= num;
                } else {
                    hiSum ^= num;
                }
            }
            if (loSum != 0 && hiSum != 0) {
                // 两个都不为0，说明 p 和 q 分别落到2个数组里了。
                return new int[] {loSum, hiSum};
            }
            if (loSum == 0) {
                // 说明 p 和 q 都比 mid 大，所以比 mid 小的数的异或和变为0了。
                lo = mid + 1;
            } else {
                // 说明 p 和 q 都不超过 mid
                hi = mid - 1;
            }
        }
        // 其实如果输入是符合要求的，程序不会执行到这里，为了防止compile error加一下
        return null;
    }
}
```

时间复杂度是$O(N*log(maxValue-minValue))$，我的这种方法只是提供一种思路，供大家参考~

---

❤️ 大佬们随手【[关注我](https://leetcode-cn.com/u/sweetiee/)】呀～
